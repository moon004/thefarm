package main

import (
	"math"
	"math/rand"
	"path/filepath"
	"strings"
	"time"

	"github.com/g3n/engine/core"
	"github.com/g3n/engine/math32"

	"github.com/g3n/engine/animation"
	"github.com/g3n/engine/loader/gltf"
	"github.com/g3n/g3nd/util"
	"github.com/pkg/errors"
)

type GltfLoader struct {
	prevLoaded core.INode
	selFile    *util.FileSelectButton
	anims      []*animation.Animation
}

// TheChar is the character generated by input facial picture
type TheChar struct {
	CN *core.Node      // That particular Character Node
	CD *math32.Vector3 // The character current ongoing destination
	CO *math32.Vector3 // Current Origin
	// cT string          // character Type: Son, Father, Mother, Daughter
}

// GenerateNewChar will return a new pointer to TheChar
// with the face input
func (tf *TheFarm) GenerateNewChar(fpath, faceID string) *TheChar {
	newchar := new(TheChar)
	newchar.CN = core.NewNode()
	n := tf.loadScene(fpath, faceID)
	newchar.CN.Add(n)
	newchar.CO = math32.NewVec3() // assign the origin to be 0,0,0
	newchar.CD = tf.randCoord()

	return newchar
}

// Render is to update gltf animation.
func (tf *TheFarm) Render(delta float32) {

	for _, anim := range tf.anims {
		anim.Update(delta)
	}
}

// MoveChar moves the all the characters
// to a random destination within a boundary.
func (tf *TheFarm) MoveChar() {

	for _, char := range tf.allChar {
		tf.translateChar(char)
	}
}

func Min(x, y float32) float32 {
	if x < y {
		return x
	}
	return y
}

func Max(x, y float32) float32 {
	if x > y {
		return x
	}
	return y
}

// Clamp returns clamped value
func Clamp(v, lo, hi float32) float32 {
	return (Min(Max(v, lo), hi))
}

// AlmostEq check equal with tolerance value
func AlmostEq(a, b, tolerance float32) bool {
	if math32.Abs(a-b) < tolerance {
		return true
	}
	return false
}

// Sign returns you the sign
func Sign(a float32) float32 {
	switch {
	case a < 0:
		return -1
	case a > 0:
		return +1
	}
	return 0
}

func (tf *TheFarm) translateChar(C *TheChar) {
	tol := float32(0.1)
	distX := C.CD.X - C.CO.X
	distZ := C.CD.Z - C.CO.Z
	dX, dZ := Sign(distX)*0.01, Sign(distZ)*0.01
	CX, CZ := C.CN.Position().X, C.CN.Position().Z

	if !AlmostEq(CX, C.CD.X, tol) {
		C.CN.TranslateX(dX) // Move node
	} else {
		C.CO.X = C.CD.X
		C.CD.X = tf.randPoint(-2, 8)
	}
	if !AlmostEq(CZ, C.CD.Z, tol) {
		C.CN.TranslateZ(dZ)
	} else {
		C.CO.Z = C.CD.Z
		C.CD.Z = tf.randPoint(-8, 6)
	}

	log.Debug("\nCurrentPos: %v, CurrentDes: %v",
		C.CN.Position(), C.CD)
}

func (tf *TheFarm) randPoint(lower, upper float64) float32 {
	nanoTime := time.Now().UnixNano()
	rand.Seed(nanoTime)
	rg := float32(math.Abs(upper - lower))
	x := (rand.Float32() * rg) + float32(lower)

	return x
}

// randCoord returns a random *Vector3 that is within the boundary
func (tf *TheFarm) randCoord() *math32.Vector3 {
	nanoTime := time.Now().UnixNano()
	rand.Seed(nanoTime)
	x := (rand.Float32() * 10) - 2 // -2 <= x <= 8
	y := float32(0.0)
	z := (rand.Float32() * 14) - 8 // -8 <= z <= 6

	log.Debug("Rand Seed: %v", nanoTime)
	return math32.NewVector3(x, y, z)
}

func (tf *TheFarm) loadScene(fpath, faceID string) core.INode {

	// TODO move camera or scale scene such that it's nicely framed
	// TODO do this for other loaders as well
	log.Debug("Add GLTF item: %s %s", fpath, faceID)

	// Checks file extension
	ext := filepath.Ext(fpath)
	var g *gltf.GLTF
	var err error
	// Parse the fpath directory
	item := strings.Split(fpath, "/")
	// Pick second last for item load type and last for faces
	itemToLoad := item[len(item)-2]
	log.Debug("ItemToLoad: %v", itemToLoad)

	// Parses file
	if ext == ".gltf" {
		g, err = gltf.ParseJSON(fpath)
		// REMEMBER ADD user facial picture HERE!!!!
		// g.Images[0].Uri = "CesiumMan1.jpg"
		switch itemToLoad {
		case "character":
			g.Images[0].Uri = "face/1.jpg"
		default: // Other than "character"
			log.Debug("Default case means to load stage")
		}
	} else if ext == ".glb" {
		g, err = gltf.ParseBin(fpath)
	} else {
		Errs(errors.Errorf("Uknown file extension:%s", ext))
	}
	Errs(err)

	defaultSceneIdx := 0
	if g.Scene != nil {
		defaultSceneIdx = *g.Scene
	}

	// Create default scene
	n, err := g.LoadScene(defaultSceneIdx)
	Errs(err)

	// Create animations
	for i := range g.Animations {
		anim, _ := g.LoadAnimation(i)
		anim.SetLoop(true)
		tf.anims = append(tf.anims, anim)
	}

	return n

}
